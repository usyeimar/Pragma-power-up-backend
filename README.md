# üè° Proyecto Home360 - Arquitectura de Microservicios üåü

¬°Hola! üëã ¬°Bienvenido/a al Proyecto "Home360"! Este documento describe la arquitectura de microservicios implementada para nuestra plataforma inmobiliaria. Est√° dise√±ado para ser una gu√≠a clara y concisa para desarrolladores y cualquier persona interesada en entender c√≥mo funciona nuestro sistema.

## üéØ Prop√≥sito

El objetivo principal de "Home360" es ofrecer una **plataforma inmobiliaria digital robusta, escalable y modular**. Buscamos facilitar la gesti√≥n integral de propiedades, usuarios, transacciones y visitas, proporcionando una experiencia de usuario fluida y eficiente, todo ello soportado por una arquitectura moderna de microservicios.

## üèóÔ∏è Arquitectura General

El sistema "Home360" se basa en una **arquitectura de microservicios**. Cada servicio es responsable de una funcionalidad de negocio espec√≠fica, lo que permite un desarrollo, despliegue y escalado independientes. Estos servicios se comunican entre s√≠, principalmente de forma s√≠ncrona a trav√©s de REST APIs.

La orquestaci√≥n de estos servicios en un entorno de desarrollo y pruebas se realiza mediante **Docker y Docker Compose**.

Componentes clave de la infraestructura incluyen:

* **Netflix Eureka**: Para el descubrimiento de servicios, permitiendo que los microservicios se encuentren din√°micamente.
* **Spring Cloud Gateway**: Act√∫a como la puerta de enlace API, manejando todas las solicitudes externas y enrut√°ndolas al servicio correspondiente. Tambi√©n se encarga de aspectos transversales como la seguridad y la agregaci√≥n de documentaci√≥n.
* **MySQL**: Como base de datos relacional principal, con esquemas separados para diferentes servicios, garantizando el aislamiento de datos.

<p align="center">
  <img src="https://placehold.co/700x450/E6F7FF/0050B3?text=Diagrama+Arquitectura+Home360+Microservicios" alt="Diagrama de Arquitectura Home360">
  <br>
  <em>Ilustraci√≥n conceptual de la arquitectura de microservicios de Home360.</em>
</p>

### üß© Componentes Principales y sus Funciones:

1.  **üö™ Service Gateway (`service-gateway`)**:
    * **Descripci√≥n**: Es el √∫nico punto de entrada (`Single Point of Entry`) para todas las peticiones de los clientes (navegadores web, aplicaciones m√≥viles, etc.). Su principal responsabilidad es recibir las solicitudes, autenticar y autorizar (si es necesario), y luego enrutarlas al microservicio interno apropiado.
    * **Tecnolog√≠a Clave**: Spring Cloud Gateway MVC.
    * **Caracter√≠sticas Destacadas**:
        * **Enrutamiento Din√°mico**: Configura rutas para dirigir el tr√°fico a los diferentes microservicios bas√°ndose en los paths de las URLs.
        * **Integraci√≥n con Service Discovery**: Utiliza Eureka para descubrir las ubicaciones de los microservicios.
        * **Seguridad Centralizada**: Act√∫a como un OAuth2 Resource Server, validando los tokens JWT recibidos en las cabeceras `Authorization`.
        * **Filtros Personalizados**: Incluye `ClaimsToHeadersFilter` que extrae informaci√≥n del JWT (como `userId` y `roles`) y la a√±ade como cabeceras (`X-User-Id`, `X-User-Roles`) a las solicitudes que se reenv√≠an a los servicios internos. Esto permite a los microservicios identificar al usuario y sus permisos sin necesidad de validar el JWT nuevamente.
        * **Agregaci√≥n de Documentaci√≥n API**: Consolida la documentaci√≥n Swagger/OpenAPI de los microservicios subyacentes, ofreciendo un √∫nico punto (`/swagger-ui.html`) para explorar todas las APIs del sistema.
    * **Puerto por Defecto**: `8080` (configurable mediante la variable de entorno `${SERVER_PORT_API_GATEWAY}`).

2.  **üß≠ Service Discovery (`service-discovery`)**:
    * **Descripci√≥n**: Implementa el patr√≥n de Descubrimiento de Servicios. Cada microservicio se registra en Eureka al arrancar, y Eureka mantiene un registro de las instancias activas y sus ubicaciones (host y puerto). Esto permite a los servicios (especialmente al API Gateway) encontrar y comunicarse con otros servicios sin necesidad de conocer sus direcciones IP de antemano.
    * **Tecnolog√≠a Clave**: Netflix Eureka Server.
    * **Puerto por Defecto**: `8761` (configurable mediante `${SERVICE_DISCOVERY_PORT}`).

3.  **‚öôÔ∏è Service Config (`service-config`)**:
    * **Descripci√≥n**: Dise√±ado para centralizar la gesti√≥n de la configuraci√≥n para todos los microservicios. En un entorno de producci√≥n t√≠pico, se conectar√≠a a un repositorio Git donde se almacenan los archivos de configuraci√≥n. Los microservicios, al arrancar, consultar√≠an a este servidor para obtener su configuraci√≥n espec√≠fica.
    * **Tecnolog√≠a Clave**: Spring Cloud Config Server.
    * **Perfil Actual**: Configurado con el perfil `native`, lo que sugiere que en el entorno de desarrollo actual podr√≠a estar sirviendo configuraciones desde el sistema de archivos local del contenedor del Config Server. Sin embargo, el `compose.yml` no muestra un montaje expl√≠cito de un directorio de configuraciones para este servicio.
    * **Uso en el Proyecto**: Aunque presente, la configuraci√≥n de los microservicios en el `compose.yml` se realiza predominantemente a trav√©s de variables de entorno. Esto podr√≠a indicar que el `service-config` se utiliza de forma limitada o est√° preparado para una configuraci√≥n m√°s avanzada en entornos de producci√≥n.
    * **Puerto por Defecto**: `8085`.

4.  **üë§ Service User (`service-user`)**:
    * **Descripci√≥n**: Microservicio dedicado a la gesti√≥n de usuarios. Maneja el registro de nuevos usuarios, la autenticaci√≥n (verificaci√≥n de credenciales y emisi√≥n de JWTs), la gesti√≥n de perfiles de usuario y roles.
    * **Tecnolog√≠as Clave**: Spring Boot, Spring Security, JWT (utilizando `nimbus-jose-jwt` para la creaci√≥n y validaci√≥n de tokens).
    * **Base de Datos**: Se conecta al esquema `services_user` en la instancia de MySQL.
    * **Caracter√≠sticas Destacadas**:
        * Endpoints para `POST /api/v1/auth/sign-in` (para iniciar sesi√≥n y obtener un JWT) y `POST /api/v1/users` (para registrar nuevos usuarios, por defecto con rol "VENDEDOR").
        * Implementa `UserDetailsService` de Spring Security para cargar los detalles del usuario durante la autenticaci√≥n.
        * Utiliza `BCryptPasswordEncoder` para el almacenamiento seguro de contrase√±as.
        * `DataInitializer`: Un `CommandLineRunner` que crea un usuario administrador por defecto si no existe al iniciar la aplicaci√≥n (configurable mediante variables de entorno `DEFAULT_USER_*`).
    * **Puerto por Defecto**: `8081` (configurable mediante `${SERVER_PORT_SERVICE_USER}`).

5.  **üè† Service Home (`service-home`)**:
    * **Descripci√≥n**: Considerado el coraz√≥n de la plataforma en cuanto a la gesti√≥n de propiedades. Es responsable de toda la l√≥gica de negocio relacionada con los inmuebles, incluyendo sus categor√≠as, ubicaciones geogr√°ficas (departamentos, ciudades, barrios), y la gesti√≥n de las im√°genes asociadas.
    * **Tecnolog√≠as Clave**: Spring Boot, Spring Data JPA.
    * **Base de Datos**: Se conecta al esquema `services_home` en la instancia de MySQL.
    * **Caracter√≠sticas Destacadas**:
        * Operaciones CRUD completas para entidades como `Category`, `Department`, `City`, `Neighborhood`, `Location`, y `Property`.
        * **Gesti√≥n de Im√°genes**: Permite la carga de im√°genes para las propiedades. Las im√°genes se almacenan en el sistema de archivos local del contenedor (`./uploads/property-images`, accesible externamente a trav√©s del API Gateway en `/media/properties/...`).
        * **Tareas Programadas**: Incluye `PropertyScheduledTasks`, una tarea que se ejecuta peri√≥dicamente (cada 60 segundos) para actualizar el estado de las propiedades cuya fecha de publicaci√≥n activa ha llegado (cambiando de `PUBLICATION_PENDING` a `PUBLISHED`).
        * **Poblaci√≥n Inicial de Datos**: `DatabaseSeeder` es un `CommandLineRunner` que carga datos maestros iniciales (departamentos, ciudades, categor√≠as, etc.) si las tablas correspondientes est√°n vac√≠as.
    * **Puerto por Defecto**: `8082` (configurable mediante `${SERVER_PORT_SERVICE_HOME}`).

6.  **üö∂ Service Visits (`service-visits`)**:
    * **Descripci√≥n**: Este microservicio est√° destinado a gestionar la programaci√≥n y seguimiento de visitas a las propiedades.
    * **Tecnolog√≠as Clave**: Spring Boot.
    * **Base de Datos**: Se conecta al esquema `services_visits` en la instancia de MySQL.
    * **Estado Actual**: La funcionalidad detallada parece estar en una fase inicial de desarrollo seg√∫n los archivos proporcionados.
    * **Puerto por Defecto**: `8083` (configurable mediante `${SERVER_PORT_SERVICE_VISITS}`).

7.  **üí∏ Service Transactions (`service-transactions`)**:
    * **Descripci√≥n**: Responsable de manejar todas las transacciones financieras y contractuales relacionadas con las propiedades, como procesos de alquiler o venta.
    * **Tecnolog√≠as Clave**: Spring Boot.
    * **Base de Datos**: Se conecta al esquema `services_transactions` en la instancia de MySQL.
    * **Estado Actual**: Similar a `service-visits`, la implementaci√≥n detallada parece estar pendiente.
    * **Puerto por Defecto**: `8084` (configurable mediante `${SERVER_PORT_SERVICE_TRANSACTIONS}`).

8.  **üóÉÔ∏è MySQL Database (`mysql-db`)**:
    * **Descripci√≥n**: Instancia de base de datos relacional que sirve como almac√©n de persistencia para todos los microservicios.
    * **Tecnolog√≠a**: MySQL versi√≥n 8.0 (imagen oficial de Docker).
    * **Configuraci√≥n**:
        * El script `init-db.sql` se ejecuta al iniciar el contenedor por primera vez, creando las bases de datos (`services_user`, `services_home`, `services_visits`, `services_transactions`) y otorgando los privilegios necesarios al usuario de la aplicaci√≥n (`365home_app`).
        * Los datos se persisten en un volumen Docker (`mysql-db-data`) para evitar la p√©rdida de datos entre reinicios del contenedor.
        * Incluye un `healthcheck` para asegurar que la base de datos est√© operativa antes de que otros servicios dependientes intenten conectarse.
    * **Puerto Expuesto (Host)**: `3306` (configurable mediante `${MYSQL_DB_PORT}`).

9.  **üõ†Ô∏è phpMyAdmin (`phpmyadmin`)**:
    * **Descripci√≥n**: Herramienta de administraci√≥n web para MySQL, que facilita la visualizaci√≥n, consulta y manipulaci√≥n de los datos en la base de datos.
    * **Tecnolog√≠a**: phpMyAdmin (imagen oficial de Docker).
    * **Acceso**: Se conecta al servicio `mysql-db`.
    * **Puerto Expuesto (Host)**: `8086` (configurable mediante `${PHPMYADMIN_PORT}`).

## üõ†Ô∏è Stack Tecnol√≥gico Principal

* **Lenguaje de Programaci√≥n**: Java 17 ‚òï
* **Framework Backend**: Spring Boot 3.x üå± (con Spring MVC, Spring Data JPA, Spring Security)
* **Gesti√≥n de Dependencias y Construcci√≥n**: Gradle üêò
* **Contenerizaci√≥n y Orquestaci√≥n**: Docker üê≥ y Docker Compose
* **Patrones y Componentes de Microservicios**:
    * **API Gateway**: Spring Cloud Gateway MVC
    * **Descubrimiento de Servicios**: Spring Cloud Netflix Eureka
    * **Configuraci√≥n Centralizada**: Spring Cloud Config Server
    * **Seguridad (Autenticaci√≥n/Autorizaci√≥n)**: Spring Security (con OAuth2 Resource Server y JWT)
* **Base de Datos**: MySQL 8.0 üê¨
* **Herramienta de Administraci√≥n de BD**: phpMyAdmin
* **Documentaci√≥n de APIs**: Swagger/OpenAPI 3 (integrado mediante `springdoc-openapi`) üìñ
* **Mapeo de Objetos (DTOs/Entidades)**: MapStruct
* **Tareas Programadas**: Spring Scheduling

## üöÄ Gu√≠a de Inicio R√°pido (Desarrollo Local)

Sigue estos pasos para configurar y ejecutar el entorno de desarrollo de "Home360":

1.  **Prerrequisitos Indispensables**:
    * Docker instalado y en ejecuci√≥n.
    * Docker Compose instalado.
    * Git para clonar el repositorio.

2.  **Clonar el Repositorio**:
    ```bash
    git clone <URL_DEL_REPOSITORIO>
    cd <NOMBRE_DEL_DIRECTORIO_DEL_PROYECTO>
    ```

3.  **Configuraci√≥n de Variables de Entorno (Opcional pero Recomendado)**:
    * Crea un archivo `.env` en la ra√≠z del proyecto. Este archivo es utilizado por Docker Compose para configurar variables de entorno.
    * Puedes copiar las variables del archivo `compose.yml` y ajustar sus valores seg√∫n sea necesario (ej. puertos, credenciales de la base de datos, secretos de JWT).
        ```env
        # Ejemplo de contenido para .env
        SERVER_PORT_API_GATEWAY=8080
        SERVICE_DISCOVERY_PORT=8761
        SERVER_PORT_SERVICE_USER=8081
        # ... (otras variables) ...
        MYSQL_ROOT_PASSWORD=tu_super_secreto_root_password
        MYSQL_USER=365home_app
        MYSQL_PASSWORD=tu_password_segura_para_app
        MYSQL_DB_PORT=3306
        # ... (JWT secrets, etc.)
        APP_JWT_SECRET=UnaClaveSecretaMuyLargaYComplejaParaHS512DeAlMenos64Bytes!NotRealSecretChangeMe
        ```
    * Si no se proporciona un archivo `.env`, Docker Compose utilizar√° los valores por defecto especificados directamente en `compose.yml` (si los hay) o las variables de entorno ya existentes en tu sistema.

4.  **Construir las Im√°genes y Levantar los Servicios**:
    * Navega a la ra√≠z del proyecto (donde se encuentra el archivo `compose.yml`).
    * Ejecuta el siguiente comando en tu terminal:
        ```bash
        docker-compose up -d --build
        ```
        * `--build`: Fuerza la reconstrucci√≥n de las im√°genes Docker si ha habido cambios en los `Dockerfile` o en el c√≥digo fuente.
        * `-d`: Ejecuta los contenedores en segundo plano (modo "detached").

5.  **Verificaci√≥n del Estado de los Servicios**:
    * Puedes ver los logs de todos los servicios con: `docker-compose logs -f`
    * Para ver los logs de un servicio espec√≠fico: `docker-compose logs -f <nombre-del-servicio>` (ej. `docker-compose logs -f service-user`).
    * **Service Discovery (Eureka Dashboard)**: Abre tu navegador y ve a `http://localhost:${SERVICE_DISCOVERY_PORT}` (por defecto `http://localhost:8761`). Deber√≠as ver los microservicios (`service-user`, `service-home`, etc.) registr√°ndose.
    * **API Gateway (Swagger UI Agregada)**: Accede a `http://localhost:${SERVER_PORT_API_GATEWAY}/swagger-ui.html` (por defecto `http://localhost:8080/swagger-ui.html`). Esta interfaz te permitir√° explorar y probar los endpoints de todos los microservicios que est√°n expuestos a trav√©s del gateway.
    * **phpMyAdmin**: Disponible en `http://localhost:${PHPMYADMIN_PORT}` (por defecto `http://localhost:8086`).
        * **Servidor**: `mysql-db` (este es el nombre del servicio de MySQL en la red Docker).
        * **Usuario Root**: `root` / **Contrase√±a**: La que hayas configurado en `${MYSQL_ROOT_PASSWORD}`.
        * **Usuario de Aplicaci√≥n**: `${MYSQL_USER}` (def. `365home_app`) / **Contrase√±a**: `${MYSQL_PASSWORD}`.

6.  **Acceso Directo a Microservicios (para depuraci√≥n)**:
    Durante el desarrollo, puede ser √∫til acceder a los microservicios directamente (aunque en producci√≥n todo el tr√°fico deber√≠a pasar por el API Gateway):
    * `service-user`: `http://localhost:${SERVER_PORT_SERVICE_USER}` (def. `8081`)
    * `service-home`: `http://localhost:${SERVER_PORT_SERVICE_HOME}` (def. `8082`)
    * `service-visits`: `http://localhost:${SERVER_PORT_SERVICE_VISITS}` (def. `8083`)
    * `service-transactions`: `http://localhost:${SERVER_PORT_SERVICE_TRANSACTIONS}` (def. `8084`)
    * `service-config`: `http://localhost:8085`

7.  **Proceso de Inicializaci√≥n de Datos**:
    * **Base de Datos**: El script `init-db.sql` se ejecuta autom√°ticamente la primera vez que se inicia el contenedor `mysql-db`, creando los esquemas (`services_user`, `services_home`, etc.) y el usuario de la aplicaci√≥n.
    * **Usuario Administrador por Defecto (`service-user`)**: El servicio de usuarios (`service-user`) tiene un componente `DataInitializer` que crea un usuario con rol de administrador (configurable v√≠a variables `app.default-user.*`) si no existe uno con el email especificado. Esto es √∫til para tener un usuario inicial para pruebas.
    * **Datos Maestros (`service-home`)**: El servicio de propiedades (`service-home`) incluye un `DatabaseSeeder` que carga datos iniciales como departamentos, ciudades, categor√≠as, etc., para facilitar el desarrollo y las pruebas.

8.  **Detener los Servicios**:
    Para detener todos los servicios, ejecuta:
    ```bash
    docker-compose down
    ```
    Si tambi√©n quieres eliminar los vol√∫menes (¬°cuidado, esto borrar√° los datos de la base de datos!):
    ```bash
    docker-compose down -v
    ```

## üìÇ Estructura Detallada del Repositorio

El proyecto est√° organizado en una estructura de monorepo, donde cada microservicio principal reside en su propio directorio.

```bash
.
‚îú‚îÄ‚îÄ service-config/         # ‚öôÔ∏è Servidor de Configuraci√≥n (Spring Cloud Config)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-discovery/      # üß≠ Servidor de Descubrimiento (Netflix Eureka)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-gateway/        # üö™ API Gateway (Spring Cloud Gateway MVC)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-home/           # üè† Microservicio de Gesti√≥n de Propiedades
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/java/com/pragma/home360/home/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/  # L√≥gica de aplicaci√≥n (DTOs, Mappers, Servicios de App)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/       # L√≥gica de Dominio (Modelos, Puertos, Casos de Uso)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/ # Adaptadores de Infraestructura (Endpoints, Repositorios, Entidades)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-transactions/   # üí∏ Microservicio de Gesti√≥n de Transacciones
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-user/           # üë§ Microservicio de Gesti√≥n de Usuarios y Autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/java/com/pragma/user360/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ configurations/ # Configuraciones de Beans, Seguridad
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ service-visits/         # üö∂ Microservicio de Gesti√≥n de Visitas
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ uploads/                # üñºÔ∏è Directorio (en el host) para im√°genes de propiedades (montado en service-home)
‚îÇ   ‚îî‚îÄ‚îÄ property-images/
‚îú‚îÄ‚îÄ compose.yml             # üê≥ Archivo principal de Docker Compose para orquestar todos los servicios
‚îú‚îÄ‚îÄ init-db.sql             # üìú Script SQL para la inicializaci√≥n de las bases de datos MySQL
‚îî‚îÄ‚îÄ README.md               # üìÑ Este archivo de documentaci√≥n
```

**Dentro de cada directorio de microservicio (ej. `service-home/`)**:

* `src/main/java/com/pragma/...(nombrepaquete)`: Contiene el c√≥digo fuente Java del servicio, usualmente siguiendo una arquitectura hexagonal o por capas (application, domain, infrastructure).
* `src/main/resources/`:
    * `application.yml` o `application.yaml`: Archivo de configuraci√≥n principal de Spring Boot para el servicio.
    * Otros recursos como scripts de migraci√≥n de base de datos (si se usara Flyway/Liquibase), plantillas, etc.
* `build.gradle`: Define las dependencias y tareas de construcci√≥n para el m√≥dulo Gradle.
* `Dockerfile`: Especifica c√≥mo construir la imagen Docker para ese microservicio.

## üîë Flujo de Seguridad y Autenticaci√≥n (JWT)

1.  **Inicio de Sesi√≥n**: El usuario env√≠a sus credenciales (email y contrase√±a) al endpoint `POST /api/v1/auth/sign-in` del `service-user` (a trav√©s del API Gateway).
2.  **Validaci√≥n y Emisi√≥n de Token**: `service-user` valida las credenciales. Si son correctas, genera un Token JWT firmado. Este token incluye informaci√≥n del usuario (como ID, email y rol) y una fecha de expiraci√≥n.
3.  **Env√≠o del Token al Cliente**: El JWT se devuelve al cliente.
4.  **Peticiones Subsecuentes**: Para acceder a recursos protegidos, el cliente debe incluir el JWT en la cabecera `Authorization` de cada petici√≥n, con el prefijo `Bearer `:
    ```
    Authorization: Bearer <TU_TOKEN_JWT_AQUI>
    ```
5.  **Validaci√≥n en API Gateway**: `service-gateway` intercepta la petici√≥n.
    * Valida la firma y la expiraci√≥n del JWT.
    * Si el token es v√°lido, el filtro `ClaimsToHeadersFilter` extrae el `userId` (del `subject` del JWT) y el `role` (de un claim personalizado).
    * Estas informaciones se a√±aden como cabeceras HTTP (`X-User-Id`, `X-User-Roles`) a la petici√≥n antes de reenviarla al microservicio correspondiente.
6.  **Procesamiento en Microservicios Internos**: Los microservicios internos reciben la petici√≥n con las cabeceras `X-User-Id` y `X-User-Roles`. Pueden usar esta informaci√≥n para l√≥gica de negocio espec√≠fica del usuario o para aplicar autorizaciones m√°s granulares si es necesario, confiando en que el API Gateway ya ha realizado la autenticaci√≥n.

## üìù Notas Adicionales y Consideraciones

* **Variables de Entorno**: La configuraci√≥n de la aplicaci√≥n se maneja fuertemente mediante variables de entorno, lo cual es una buena pr√°ctica para la contenerizaci√≥n y diferentes entornos (desarrollo, staging, producci√≥n). Aseg√∫rate de revisar y configurar adecuadamente el archivo `.env` o las variables de tu sistema.
* **Almacenamiento de Im√°genes (`service-home`)**: Las im√°genes de las propiedades se almacenan en el sistema de archivos del host, en el directorio `./uploads/property-images`, que est√° montado dentro del contenedor de `service-home` en `/app/uploads/property-images`. El servicio genera URLs relativas (ej. `/media/properties/<propertyId>/<imageName>`) que son resueltas por el API Gateway para servir los archivos.
* **Logs de Contenedores**: Para monitorizar o depurar, los logs de cada servicio son accesibles mediante Docker Compose: `docker-compose logs -f [nombre-del-servicio]`.
* **Escalabilidad**: La arquitectura de microservicios permite escalar cada servicio de forma independiente seg√∫n la carga. En un entorno de producci√≥n, se utilizar√≠an orquestadores como Kubernetes.
* **Pruebas**: Cada microservicio contiene pruebas unitarias y de integraci√≥n (ej. `CategoryUseCaseTest.java` en `service-home`). Es fundamental mantener y ampliar la cobertura de pruebas.

---
